<?php declare(strict_types=1);

/*
 * This file is part of PHP CS Fixer: custom fixers.
 *
 * (c) 2018 Kuba WerÅ‚os
 *
 * For the full copyright and license information, please view
 * the LICENSE file that was distributed with this source code.
 */

namespace PhpCsFixerCustomFixersDev\Readme;

use PhpCsFixer\Fixer\ConfigurableFixerInterface;
use PhpCsFixer\Fixer\DeprecatedFixerInterface;
use PhpCsFixer\Fixer\WhitespacesAwareFixerInterface;
use PhpCsFixer\FixerDefinition\CodeSampleInterface;
use PhpCsFixer\Tokenizer\Tokens;
use PhpCsFixer\Utils;
use PhpCsFixer\WhitespacesFixerConfig;
use PhpCsFixerCustomFixers\Fixer\AbstractFixer;
use PhpCsFixerCustomFixers\Fixer\DataProviderStaticFixer;
use PhpCsFixerCustomFixers\Fixers;
use SebastianBergmann\Diff\Differ;
use SebastianBergmann\Diff\Output\StrictUnifiedDiffOutputBuilder;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Process;

/**
 * @internal
 */
#[AsCommand(name: 'readme')]
final class ReadmeCommand extends Command
{
    private const NAME = 'PHP CS Fixer: custom fixers';
    private const SHIELDS_HOST = 'https://img.shields.io';

    protected static $defaultName = 'readme';

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $output->write(
            "<!-- This file is generated by ReadmeCommand -->\n\n"
            . \sprintf('# %s', self::NAME) . "\n\n"
            . self::badges() . "\n\n"
            . self::description() . "\n\n"
            . self::installation() . "\n\n"
            . self::usage() . "\n\n"
            . self::fixers() . "\n\n"
            . self::contributing() . "\n",
        );

        return self::SUCCESS;
    }

    private static function badges(): string
    {
        return \implode("\n", [
            self::badge(
                'Latest stable version',
                \sprintf('%s/packagist/v/%s.svg?label=current%%20version', self::SHIELDS_HOST, self::composer()->name),
                \sprintf('https://packagist.org/packages/%s', self::composer()->name),
            ),
            self::badge(
                'PHP version',
                \sprintf('%s/packagist/php-v/%s.svg', self::SHIELDS_HOST, self::composer()->name),
                'https://php.net',
            ),
            self::badge(
                'License',
                \sprintf('%s/github/license/%s.svg', self::SHIELDS_HOST, self::composer()->name),
                'LICENSE',
            ),
            self::badge(
                'Tests',
                \sprintf('%s/badge/tests-%d-brightgreen.svg', self::SHIELDS_HOST, self::numberOfTests()),
            ),
            self::badge(
                'Downloads',
                \sprintf('%s/packagist/dt/%s.svg', self::SHIELDS_HOST, self::composer()->name),
                \sprintf('https://packagist.org/packages/%s', self::composer()->name),
            ),
            '',
            self::badge(
                'CI status',
                \sprintf('https://github.com/%s/actions/workflows/ci.yaml/badge.svg', self::composer()->name),
                \sprintf('https://github.com/%s/actions/workflows/ci.yaml', self::composer()->name),
            ),
            self::badge(
                'Code coverage',
                \sprintf('%s/coveralls/github/%s/main.svg', self::SHIELDS_HOST, self::composer()->name),
                \sprintf('https://coveralls.io/github/%s?branch=main', self::composer()->name),
            ),
            self::badge(
                'Mutation testing badge',
                \sprintf(
                    'https://img.shields.io/endpoint?style=flat&url=%s',
                    \rawurlencode(\sprintf('https://badge-api.stryker-mutator.io/github.com/%s/main', self::composer()->name)),
                ),
                \sprintf('https://dashboard.stryker-mutator.io/reports/github.com/%s/main', self::composer()->name),
            ),
            self::badge(
                'Psalm type coverage',
                \sprintf('https://shepherd.dev/github/%s/coverage.svg', self::composer()->name),
                \sprintf('https://shepherd.dev/github/%s', self::composer()->name),
            ),
        ]);
    }

    private static function badge(string $description, string $imageUrl, ?string $targetUrl = null): string
    {
        $badge = \sprintf('![%s](%s)', $description, $imageUrl);

        if ($targetUrl !== null) {
            $badge = \sprintf('[%s](%s)', $badge, $targetUrl);
        }

        return $badge;
    }

    private static function numberOfTests(): int
    {
        $process = new Process([__DIR__ . '/../../../vendor/bin/phpunit', '--list-tests'], __DIR__ . '/../../..');
        $process->run();

        return \substr_count($process->getOutput(), \PHP_EOL) - 3; // 3 is for header
    }

    private static function description(): string
    {
        return \str_replace(
            'PHP CS Fixer',
            '[PHP CS Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer)',
            self::composer()->description,
        ) . '.';
    }

    private static function installation(): string
    {
        return \sprintf(
            '## Installation
%s can be installed by running:
```bash
composer require --dev %s
```
',
            self::NAME,
            self::composer()->name,
        );
    }

    private static function usage(): string
    {
        return \sprintf(
            '## Usage
In your PHP CS Fixer configuration register fixers and use them:
```diff
%s
```
:warning: When PHP CS Fixer is installed via [`php-cs-fixer/shim`](https://github.com/PHP-CS-Fixer/shim) package,
requiring bootstrap may be needed to load `PhpCsFixerCustomFixers` classes:
```php
require __DIR__ . \'/vendor/%s/bootstrap.php\';
```
',
            self::diff(
                \file_get_contents(__DIR__ . '/php-cs-fixer.config.before.txt'),
                \file_get_contents(__DIR__ . '/php-cs-fixer.config.after.txt'),
            ),
            self::composer()->name,
        );
    }

    private static function fixers(): string
    {
        $output = '## Fixers';

        /** @var AbstractFixer $fixer */
        foreach (new Fixers() as $fixer) {
            if ($fixer instanceof WhitespacesAwareFixerInterface) {
                $fixer->setWhitespacesConfig(new WhitespacesFixerConfig());
            }

            $reflectionClass = new \ReflectionClass($fixer);

            $output .= \sprintf(
                "\n#### %s\n%s",
                $reflectionClass->getShortName(),
                $fixer->getDefinition()->getSummary(),
            );

            $output .= $fixer instanceof DeprecatedFixerInterface ? \sprintf("\n  DEPRECATED: use `%s` instead.", \implode('`, `', $fixer->getSuccessorsNames())) : '';

            if ($fixer instanceof DataProviderStaticFixer) {
                $fixer->configure(['force' => true]);
            }
            if ($fixer->isRisky()) {
                $riskyDescription = $fixer->getDefinition()->getRiskyDescription();
                $starts = [
                    'Risky when' => 'when',
                    'Fixer could be risky if' => 'when',
                ];
                foreach ($starts as $from => $to) {
                    if (\str_starts_with($riskyDescription, $from)) {
                        $riskyDescription = $to . \substr($riskyDescription, \strlen($from));
                    }
                }
                $output .= \sprintf(
                    "\n  *Risky: %s.*",
                    \lcfirst(\rtrim($riskyDescription, '.')),
                );
            }
            if ($fixer instanceof DataProviderStaticFixer) {
                $fixer->configure(['force' => false]);
            }

            if ($fixer instanceof ConfigurableFixerInterface) {
                $output .= "\nConfiguration options:";

                foreach ($fixer->getConfigurationDefinition()->getOptions() as $option) {
                    if ($option->getAllowedValues() !== null) {
                        $allowed = \array_map(static fn (string $value): string => \sprintf('\'%s\'', $value), $option->getAllowedValues());
                    } else {
                        /** @var list<string> $allowed */
                        $allowed = $option->getAllowedTypes();
                    }
                    $output .= \sprintf(
                        "\n- `%s` (`%s`): %s; defaults to `%s`",
                        $option->getName(),
                        \implode('`, `', $allowed),
                        \lcfirst(\rtrim($option->getDescription(), '.')),
                        Utils::toString($option->getDefault()),
                    );
                }
            }

            $codeSample = $fixer->getDefinition()->getCodeSamples()[0];
            \assert($codeSample instanceof CodeSampleInterface);

            $originalCode = $codeSample->getCode();
            if ($fixer instanceof ConfigurableFixerInterface) {
                $fixer->configure($codeSample->getConfiguration() ?? []);
            }
            $tokens = Tokens::fromCode($originalCode);
            $fixer->fix(self::createSplFileInfoDouble(), $tokens);
            $fixedCode = $tokens->generateCode();

            $output .= \sprintf(
                "\n```diff\n%s\n```\n",
                self::diff($originalCode, $fixedCode),
            );
        }

        return $output;
    }

    private static function diff(string $from, string $to): string
    {
        static $differ;

        if ($differ === null) {
            $differ = new Differ(new StrictUnifiedDiffOutputBuilder([
                'contextLines' => 1024,
                'fromFile' => '',
                'toFile' => '',
            ]));
        }

        $diff = $differ->diff($from, $to);

        $start = \strpos($diff, "\n", 10);
        \assert(\is_int($start));

        return \substr($diff, $start + 1, -1);
    }

    private static function createSplFileInfoDouble(): \SplFileInfo
    {
        return new class (\getcwd() . \DIRECTORY_SEPARATOR . 'file.php') extends \SplFileInfo {
            public function __construct(string $filename)
            {
                parent::__construct($filename);
            }

            public function getRealPath(): string
            {
                return $this->getPathname();
            }
        };
    }

    private static function contributing(): string
    {
        return \sprintf(
            '## Contributing
Request a feature or report a bug by creating an [issue](https://github.com/%s/issues).

Alternatively, fork the repository, commit your changes, and make sure everything is fine:
```bash
composer verify
```
and submit a pull request.',
            self::composer()->name,
        );
    }

    private static function composer(): \stdClass
    {
        return \json_decode(\file_get_contents(__DIR__ . '/../../../composer.json'));
    }
}
